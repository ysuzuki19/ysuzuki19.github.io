{"pageProps":{"toc":[{"content":"はじめに","slug":"はじめに","lvl":2,"i":0},{"content":"よくある集","slug":"よくある集","lvl":2,"i":1},{"content":"アルゴリズムが対応する入力値","slug":"アルゴリズムが対応する入力値","lvl":3,"i":2},{"content":"range-based-for","slug":"range-based-for","lvl":3,"i":3},{"content":"ラムダ式","slug":"ラムダ式","lvl":3,"i":4},{"content":"式定義後の忘れ物","slug":"式定義後の忘れ物","lvl":4,"i":5},{"content":"キャプチャの追加","slug":"キャプチャの追加","lvl":4,"i":6},{"content":"式定義の更新忘れ","slug":"式定義の更新忘れ","lvl":4,"i":7},{"content":"エラーメッセージへの対処","slug":"エラーメッセージへの対処","lvl":2,"i":8},{"content":"func was not declared in this scope","slug":"func-was-not-declared-in-this-scope","lvl":3,"i":9},{"content":"おわりに","slug":"おわりに","lvl":2,"i":10}],"source":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    h2: \"h2\",\n    a: \"a\",\n    span: \"span\",\n    p: \"p\",\n    h3: \"h3\",\n    code: \"code\",\n    h4: \"h4\"\n  }, _provideComponents(), props.components);\n  return _jsxs(_Fragment, {\n    children: [_jsxs(_components.h2, {\n      id: \"はじめに\",\n      children: [_jsx(_components.a, {\n        \"aria-hidden\": \"true\",\n        tabIndex: \"-1\",\n        href: \"#はじめに\",\n        children: _jsx(_components.span, {\n          className: \"icon icon-link\"\n        })\n      }), \"はじめに\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"普段の開発（およびプログラミング学習）では、とりあえず目的を”果たすであろう”プログラムを思うがままに書き、コンパイラのメッセージを読んでからコードを直すようにしている。\\nしかし、その方法ではいちいちコンパイルメッセージを確認する必要があるため、開発速度を損なう可能性があると感じた。また、ホワイトボードコーディング等ではコンパイラメッセージを元にコードミス（タイポ含む）を都度確認する事ができない場合がある。\\nよって、コーディング中にコンパイルなしでデバッグする意義が少しはあるのではないかと感じた。\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"そこで、自分がコンパイルした際によく引き起こすエラーを備忘録として目に見える形にする事で、コンパイル前の目視確認のポイントを具体化しようと考えた。\"\n    }), \"\\n\", _jsxs(_components.h2, {\n      id: \"よくある集\",\n      children: [_jsx(_components.a, {\n        \"aria-hidden\": \"true\",\n        tabIndex: \"-1\",\n        href: \"#よくある集\",\n        children: _jsx(_components.span, {\n          className: \"icon icon-link\"\n        })\n      }), \"よくある集\"]\n    }), \"\\n\", _jsxs(_components.h3, {\n      id: \"アルゴリズムが対応する入力値\",\n      children: [_jsx(_components.a, {\n        \"aria-hidden\": \"true\",\n        tabIndex: \"-1\",\n        href: \"#アルゴリズムが対応する入力値\",\n        children: _jsx(_components.span, {\n          className: \"icon icon-link\"\n        })\n      }), \"アルゴリズムが対応する入力値\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"配列を引数とする場合、要素が空の場合には対応できないアルゴリズムを書く事がたまにある。\\nその際に、関数の最初に早期リターンするのだが、よく忘れる。\"\n    }), \"\\n\", _jsxs(_components.h3, {\n      id: \"range-based-for\",\n      children: [_jsx(_components.a, {\n        \"aria-hidden\": \"true\",\n        tabIndex: \"-1\",\n        href: \"#range-based-for\",\n        children: _jsx(_components.span, {\n          className: \"icon icon-link\"\n        })\n      }), \"range-based-for\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"配列に対してのループ処理において、プログラムを簡潔に記述するために、for/range-based-for を切り替える事がよくある。その際、要素の表現\", _jsx(_components.code, {\n        children: \"v[i]/e\"\n      }), \"を更新し忘れてしまう事がよくある。\"]\n    }), \"\\n\", _jsxs(_components.h3, {\n      id: \"ラムダ式\",\n      children: [_jsx(_components.a, {\n        \"aria-hidden\": \"true\",\n        tabIndex: \"-1\",\n        href: \"#ラムダ式\",\n        children: _jsx(_components.span, {\n          className: \"icon icon-link\"\n        })\n      }), \"ラムダ式\"]\n    }), \"\\n\", _jsxs(_components.h4, {\n      id: \"式定義後の忘れ物\",\n      children: [_jsx(_components.a, {\n        \"aria-hidden\": \"true\",\n        tabIndex: \"-1\",\n        href: \"#式定義後の忘れ物\",\n        children: _jsx(_components.span, {\n          className: \"icon icon-link\"\n        })\n      }), \"式定義後の忘れ物\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"ラムダ式を定義する時は、関数のようなイメージで定義する。普通の関数は末尾に\", _jsx(_components.code, {\n        children: \";\"\n      }), \"が不要なため、ラムダ式においてもついつい忘れてしまう。\"]\n    }), \"\\n\", _jsxs(_components.h4, {\n      id: \"キャプチャの追加\",\n      children: [_jsx(_components.a, {\n        \"aria-hidden\": \"true\",\n        tabIndex: \"-1\",\n        href: \"#キャプチャの追加\",\n        children: _jsx(_components.span, {\n          className: \"icon icon-link\"\n        })\n      }), \"キャプチャの追加\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [_jsx(_components.code, {\n        children: \"[&]\"\n      }), \"として全てキャプチャしている場合は関係ないが、各変数に対してキャプチャを設定している場合は注意が必要。\\n式の記述と共に必要な変数が増える事で式内部で扱う変数をキャプチャし忘れてしまう場合がある。\"]\n    }), \"\\n\", _jsxs(_components.h4, {\n      id: \"式定義の更新忘れ\",\n      children: [_jsx(_components.a, {\n        \"aria-hidden\": \"true\",\n        tabIndex: \"-1\",\n        href: \"#式定義の更新忘れ\",\n        children: _jsx(_components.span, {\n          className: \"icon icon-link\"\n        })\n      }), \"式定義の更新忘れ\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [_jsx(_components.code, {\n        children: \"auto [](){};\"\n      }), \"の場合は心配する必要がないが、私の場合は（是非はともかくとして）ラムダを再帰するために予め\", _jsx(_components.code, {\n        children: \"function<void(int, int)>\"\n      }), \"のように定義している。その際、式記述中に宣言行記述時よりも脳内が整理されて戻り値・引数を変更したくなる事がよくある。その場合、戻り値・引数を式内部では変更しているが式の定義の方を更新し忘れてしまう事がよくある。\"]\n    }), \"\\n\", _jsxs(_components.h2, {\n      id: \"エラーメッセージへの対処\",\n      children: [_jsx(_components.a, {\n        \"aria-hidden\": \"true\",\n        tabIndex: \"-1\",\n        href: \"#エラーメッセージへの対処\",\n        children: _jsx(_components.span, {\n          className: \"icon icon-link\"\n        })\n      }), \"エラーメッセージへの対処\"]\n    }), \"\\n\", _jsxs(_components.h3, {\n      id: \"func-was-not-declared-in-this-scope\",\n      children: [_jsx(_components.a, {\n        \"aria-hidden\": \"true\",\n        tabIndex: \"-1\",\n        href: \"#func-was-not-declared-in-this-scope\",\n        children: _jsx(_components.span, {\n          className: \"icon icon-link\"\n        })\n      }), \"func was not declared in this scope\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"関数が宣言されていないと言われている。\\n\", _jsx(_components.code, {\n        children: \"std::\"\n      }), \"の関数であれば、\", _jsx(_components.code, {\n        children: \"std::func\"\n      }), \"とする事で対応できる。\"]\n    }), \"\\n\", _jsxs(_components.h2, {\n      id: \"おわりに\",\n      children: [_jsx(_components.a, {\n        \"aria-hidden\": \"true\",\n        tabIndex: \"-1\",\n        href: \"#おわりに\",\n        children: _jsx(_components.span, {\n          className: \"icon icon-link\"\n        })\n      }), \"おわりに\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"頻出順による掲載順変更を含めて、随時更新しようと思う。\"\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}},"scope":{"title":"C++やらかし集[随時更新]","date":"2020-05-01T02:08:44+09:00","description":"脳内コンパイラを育てたかった","tags":["c++"]}},"__N_SSG":true}