{"pageProps":{"toc":[{"content":"はじめに","slug":"はじめに","lvl":2,"i":0},{"content":"前提","slug":"前提","lvl":2,"i":1},{"content":"課題解決のためのアプローチ","slug":"課題解決のためのアプローチ","lvl":2,"i":2},{"content":"検索手法","slug":"検索手法","lvl":2,"i":3},{"content":"実装について","slug":"実装について","lvl":2,"i":4},{"content":"初期実装","slug":"初期実装","lvl":3,"i":5},{"content":"インデクシングにおけるキャッシュの導入","slug":"インデクシングにおけるキャッシュの導入","lvl":3,"i":6},{"content":"インデックス分割による初期ロードの高速化","slug":"インデックス分割による初期ロードの高速化","lvl":3,"i":7},{"content":"余分なFetchを削減","slug":"余分なfetchを削減","lvl":3,"i":8},{"content":"おわりに","slug":"おわりに","lvl":2,"i":9},{"content":"参考","slug":"参考","lvl":2,"i":10}],"source":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    h2: \"h2\",\n    a: \"a\",\n    span: \"span\",\n    p: \"p\",\n    ul: \"ul\",\n    li: \"li\",\n    code: \"code\",\n    h3: \"h3\"\n  }, _provideComponents(), props.components);\n  return _jsxs(_Fragment, {\n    children: [_jsxs(_components.h2, {\n      id: \"はじめに\",\n      children: [_jsx(_components.a, {\n        \"aria-hidden\": \"true\",\n        tabIndex: \"-1\",\n        href: \"#はじめに\",\n        children: _jsx(_components.span, {\n          className: \"icon icon-link\"\n        })\n      }), \"はじめに\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"個人ブログである\", _jsx(_components.a, {\n        href: \"/\",\n        children: \"本サイト\"\n      }), \"への検索エンジンの実装および、その発展の変遷についての話の備忘録。\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"post数もだいぶ増えていて、簡易なものでも検索エンジンを導入したかった。\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"完璧なものである必要はなく、キーワードを前提とした（ほぼ）全文検索を実現したかった。\"\n    }), \"\\n\", _jsxs(_components.h2, {\n      id: \"前提\",\n      children: [_jsx(_components.a, {\n        \"aria-hidden\": \"true\",\n        tabIndex: \"-1\",\n        href: \"#前提\",\n        children: _jsx(_components.span, {\n          className: \"icon icon-link\"\n        })\n      }), \"前提\"]\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [\"ブログはNext.js (SSG)で構築されている\\n\", _jsxs(_components.ul, {\n          children: [\"\\n\", _jsx(_components.li, {\n            children: \"SSGで生成した静的ファイルをGitHub Pagesでホスティングしているため、ビルド時に自由な処理を実行できるものとする\"\n          }), \"\\n\"]\n        }), \"\\n\"]\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"個人ブログなので、継続性のためにランニングコストを抑えたく、バックエンドサーバは用いない\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsxs(_components.h2, {\n      id: \"課題解決のためのアプローチ\",\n      children: [_jsx(_components.a, {\n        \"aria-hidden\": \"true\",\n        tabIndex: \"-1\",\n        href: \"#課題解決のためのアプローチ\",\n        children: _jsx(_components.span, {\n          className: \"icon icon-link\"\n        })\n      }), \"課題解決のためのアプローチ\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"まずはSSGであることを活かして、 \", _jsx(_components.code, {\n        children: \"next build\"\n      }), \"のタイミングでインデックスを生成し、そのインデックスをフロント側で用いて、ローカルで検索するというアプローチを目指すことにした。\"]\n    }), \"\\n\", _jsxs(_components.h2, {\n      id: \"検索手法\",\n      children: [_jsx(_components.a, {\n        \"aria-hidden\": \"true\",\n        tabIndex: \"-1\",\n        href: \"#検索手法\",\n        children: _jsx(_components.span, {\n          className: \"icon icon-link\"\n        })\n      }), \"検索手法\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"全文検索エンジンをイメージしていたので、転置インデックスか n-gramのどちらか（もしくは両方）を用いるのが頭に浮かんだ。\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"それらの取捨選択についてだが、ここでの実装ではフロントがインデックスを取得することになるので、完全な全文検索よりもインデックスの軽さを重視し、n-gramは用いずに、形態素解析を用いた転置インデックスを採用することにした。\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"この決定により、検索できるワードは限定され、細かいニュアンスや接頭辞検索などはできず、単語検索エンジンを目指すことになった。\"\n    }), \"\\n\", _jsxs(_components.h2, {\n      id: \"実装について\",\n      children: [_jsx(_components.a, {\n        \"aria-hidden\": \"true\",\n        tabIndex: \"-1\",\n        href: \"#実装について\",\n        children: _jsx(_components.span, {\n          className: \"icon icon-link\"\n        })\n      }), \"実装について\"]\n    }), \"\\n\", _jsxs(_components.h3, {\n      id: \"初期実装\",\n      children: [_jsx(_components.a, {\n        \"aria-hidden\": \"true\",\n        tabIndex: \"-1\",\n        href: \"#初期実装\",\n        children: _jsx(_components.span, {\n          className: \"icon icon-link\"\n        })\n      }), \"初期実装\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"形態素解析は \", _jsx(_components.code, {\n        children: \"kuromoji\"\n      }), \"を用い、その結果から stop-wordsの除去と名詞の抽出を行い、それを \", _jsx(_components.code, {\n        children: \"Record<string, {slug:string; count:number}>\"\n      }), \"のような形式でJSONに保存し、これをインデックスとして用いることにした。\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"これをフロントエンド側で \", _jsx(_components.code, {\n        children: \"import\"\n      }), \"し、これを利用して単語検索およびその結果表示を行うコンポーネントでそれを利用した。\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"動作例は以下の通り。\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.code, {\n          children: \"rust\"\n        }), \"という単語を検索した時は、その \", _jsx(_components.code, {\n          children: \"count\"\n        }), \"で降順ソートし表示\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.code, {\n          children: \"react typescript\"\n        }), \"で検索したときは \", _jsx(_components.code, {\n          children: \"react\"\n        }), \"と\", _jsx(_components.code, {\n          children: \"typescript\"\n        }), \"の両方が含まれる記事を、それらの \", _jsx(_components.code, {\n          children: \"count\"\n        }), \"の和で降順ソートし表示\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"この時点で静的解析エンジンの全容は完成している。\"\n    }), \"\\n\", _jsxs(_components.h3, {\n      id: \"インデクシングにおけるキャッシュの導入\",\n      children: [_jsx(_components.a, {\n        \"aria-hidden\": \"true\",\n        tabIndex: \"-1\",\n        href: \"#インデクシングにおけるキャッシュの導入\",\n        children: _jsx(_components.span, {\n          className: \"icon icon-link\"\n        })\n      }), \"インデクシングにおけるキャッシュの導入\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [_jsx(_components.code, {\n        children: \"next build\"\n      }), \"する毎にすべてのファイルのインデックスを生成しており、ビルド時間がいたずらに増えていった。\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"そこで、形態素解析の結果をキャッシュし、変更がないファイルについては再解析を行わないようにすることで、ビルド時間の短縮を実現した。\"\n    }), \"\\n\", _jsxs(_components.h3, {\n      id: \"インデックス分割による初期ロードの高速化\",\n      children: [_jsx(_components.a, {\n        \"aria-hidden\": \"true\",\n        tabIndex: \"-1\",\n        href: \"#インデックス分割による初期ロードの高速化\",\n        children: _jsx(_components.span, {\n          className: \"icon icon-link\"\n        })\n      }), \"インデックス分割による初期ロードの高速化\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"ここまで読むと想像がつくと思うが、かなり大きいJSONを初期ロード時に必ず読み込むことになってしまっている。\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"そしてこれは、postが増えていくにつれて増えていくことが考えられる。\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"初期表示時間短縮のための手法として、\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [\"① \", _jsx(_components.code, {\n          children: \"{slug:string; count:number}\"\n        }), \"を \", _jsx(_components.code, {\n          children: \"{id:number, count:number}\"\n        }), \"にし、別途 \", _jsx(_components.code, {\n          children: \"{id:number, slug:string}\"\n        }), \"を用意する\"]\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"② 単語ごとにインデックスを分割する\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"という手法が考えられた。両方とも必要な対策ではあるものの、①はより最適化を目指す場合に有効ではあるがこれだけでは記事数の増加に対処できず、②は初期ロードを抜本的に抑えつつ記事の増加による影響も少ないと考察した。\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"そこで、将来①をやる可能性はあるものの、まずは②を実現した。\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"各単語のインデックスを（ \", _jsx(_components.code, {\n        children: \"rust\"\n      }), \"であれば \", _jsx(_components.code, {\n        children: \"rust.json\"\n      }), \"として）準備し、それを \", _jsx(_components.code, {\n        children: \"public/\"\n      }), \"の配下に配置し、SSGの結果とともに静的ホスティングにアップロードした。\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"フロントでは初期では空のインデックスを持ち、単語を入力する毎に、静的ホスティングからインデックスをFetchし、それをフロントでマージし、実装済みの検索につなげた。一度Fetchしたインデックスはフロントでキャッシュし、再度Fetchすることはない。\"\n    }), \"\\n\", _jsxs(_components.h3, {\n      id: \"余分なfetchを削減\",\n      children: [_jsx(_components.a, {\n        \"aria-hidden\": \"true\",\n        tabIndex: \"-1\",\n        href: \"#余分なfetchを削減\",\n        children: _jsx(_components.span, {\n          className: \"icon icon-link\"\n        })\n      }), \"余分なFetchを削減\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"インデックスを分割したことにより、初期ロード時の負荷は減ったが、それに伴い、入力文字すべてをFetchしてしまうと、入力毎に存在しないインデックスもリクエストするようになった。\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"これでは、無駄なFetchが発生して嬉しくなかった。\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"そこで、初期ロードを遅くしてしまうが、妥協案として、「インデックスが存在する単語リスト」を初期にロードし、それを元にFetchの有無を判断することで、Fetchの回数を必要最低限に抑えた。\"\n    }), \"\\n\", _jsxs(_components.h2, {\n      id: \"おわりに\",\n      children: [_jsx(_components.a, {\n        \"aria-hidden\": \"true\",\n        tabIndex: \"-1\",\n        href: \"#おわりに\",\n        children: _jsx(_components.span, {\n          className: \"icon icon-link\"\n        })\n      }), \"おわりに\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"通常の全文検索エンジンとは経路が違うものの、それに近い実装を経験することができた上、フロントエンドにおけるレンダリング時間の改善を意識した開発ができたので、非常に楽しかった。\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"より完璧な検索エンジンを用いる場合は、バックエンドサーバを用意したほうが良さそうではあるが、フロントでできる中ではきちんとした検索エンジンが完成したので満足した。\"\n    }), \"\\n\", _jsxs(_components.h2, {\n      id: \"参考\",\n      children: [_jsx(_components.a, {\n        \"aria-hidden\": \"true\",\n        tabIndex: \"-1\",\n        href: \"#参考\",\n        children: _jsx(_components.span, {\n          className: \"icon icon-link\"\n        })\n      }), \"参考\"]\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}},"scope":{"title":"個人ブログへの静的検索エンジンの実装とその変遷の話","date":"2024-05-08T21:58:36+09:00","description":"静的ホスティングとともにサーバレスで動く検索エンジン","tags":["blog","nextjs","ssg"]}},"__N_SSG":true}